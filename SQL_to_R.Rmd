---
title: "DVD Rental Company Analysis"
author: "Billy Houseman"
output: 
  html_document:
    code_folding: hide
    theme: cerulean
---
<style>
body {
font-size: 14pt;
}
</style>
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(message = FALSE, warning = FALSE)

library(RPostgres)
library(DBI)
library(DT)
library(tidyverse)
library(lubridate)
library(xlsx)
library(openxlsx)



setwd("C:/Users/house/Desktop/further work")

excel_example <- read.csv("excel_check.csv", header = T)

```


# Project Introduction
Within this project we will analyse the database for a hypothetical DVD rental business and attempt to answer some interesting questions about this fictional business. This database is the pagila / sakila fictional movie rental database. 

Within Part 1, SQL will be used to query the database. In Part 2 some automated calculations and data checks will be carried out and exported to an excel file using R.

NOTE: All the code will be hidden, if you wish to display all the code you can click the "code" button at the top right corner of this document. Individual code chunks can also be revealed by clicking the "code" buttons that appear on the right-hand side of the document in the relevant sections. 

# Part 1 - Database analysis
As mentioned, this database is the pagila database for a fictional movie rental company. The entity relationship diagram (ER) can be found below:

$~$

![](https://www.postgresqltutorial.com/wp-content/uploads/2018/03/dvd-rental-sample-database-diagram.png)

$~$

This diagram details the relationships between the tables within the database.


## Connecting to the database
We first connect to the database, in this case a localhost database using Postgres, providing the password, host, port and database name. We are using a created custom user, this user is the owner (Admin) of the database.

```{r connect to database}

pw <- {
  "password"
}


con <- dbConnect(RPostgres::Postgres()
                 , host = 'localhost'
                 , port = '5432'
                 , dbname = 'dvdrental'
                 , user = 'Billy'
                 , password = pw)

```


## The Revenue
We will first explore the revenue generated by the DVD rental business. The total revenue generated is 61,312. 

```{r total revenue}
df_total_revenue <- dbGetQuery(con, "SELECT SUM(amount) AS total_revenue
                               FROM payment")

dt_total_revenue <- datatable(df_total_revenue, rownames = FALSE, class = 'cell-border stripe',
           options = list(dom = 't',
                          columnDefs = list(list(className = 'dt-center', targets = "total_revenue"))))

dt_total_revenue

```

$~$

The revenue broken down by week can be found below. The most profitable week was the week starting 2007-03-19, with a revenue of 13085.

```{r revenue by week}
df_revenue_week <- dbGetQuery(con, "SELECT DATE_TRUNC('week', payment_date)::DATE AS payment_week,
                              SUM(amount) AS revenue
                              FROM payment
                              GROUP BY payment_week
                              ORDER BY payment_week ASC;")

dt_revenue_week <- datatable(df_revenue_week, rownames = FALSE, class = 'cell-border stripe',
                             caption = 'Total Revenue by Week',
                             options = list(dom = 't')) %>%
  formatStyle("revenue",
              background = styleColorBar(1:13100, 'lightgreen'),
              backgroundSize = '98% 88%',
              backgroundRepeat = 'no-repeat',
              backgroundPosition = 'center')

dt_revenue_week

```

$~$

Next, we will explore the total revenue by genre. This can allow us to assess our popular genres and identify what genre of movies we should introduce in future promotions. Currently we have 16 genres. Our top 3 genres by total revenue are:

* Sports
* Sci-Fi
* Animation

Additionally, this query has identified an issue within our database. The genre "New" is not very descriptive, clearly it indicates that the movie is new to our products, but this information should be stored in a separate table.

```{r total revenue by genre}
# Revenue by genre
df_revenue_genre <- dbGetQuery(con, "WITH revenue_genre AS (
                               SELECT c.name AS genre, p.amount
                               FROM payment AS p
                               INNER JOIN rental AS r
                               ON p.rental_id = r.rental_id
                               INNER JOIN inventory AS i
                               ON r.inventory_id = i.inventory_id
                               INNER JOIN film_category AS fc
                               ON i.film_id = fc.film_id
                               INNER JOIN category AS c
                               ON fc.category_id = c.category_id)
                               SELECT genre, SUM(amount) AS revenue
                               FROM revenue_genre
                               GROUP BY genre
                               ORDER BY revenue DESC")


dt_revenue_genre <- datatable(df_revenue_genre, rownames = FALSE, class = 'cell-border stripe',
                              caption = 'Total Revenue by Genre',
                              options = list(dom = 'tp'))

dt_revenue_genre

```

$~$

In the following query we extract the total revenue by week, additionally, we extract the revenue of the previous week. This allows us to easily compare the revenue change and identify weeks with a significant decrease.

```{r revenue by week and previous week}
df_revenue_week_compare <- dbGetQuery(con, "WITH revnue_week AS (
                                      SELECT DATE_TRUNC('week', payment_date)::DATE AS payment_week,
                                      SUM(amount) AS revenue
                                      FROM payment
                                      GROUP BY payment_week),
                                      
                                      revenue_week_lag AS(
                                      SELECT payment_week,
                                      revenue,
                                      GREATEST(LAG(revenue) OVER (ORDER BY payment_week ASC), 1) AS last_revenue
                                      FROM revnue_week)
                                      
                                      SELECT payment_week,
                                      revenue,
                                      last_revenue,
                                      ROUND(((revenue - last_revenue)::NUMERIC / last_revenue) * 100 , 2) AS change
                                      FROM revenue_week_lag
                                      ORDER BY payment_week ASC;")


dt_revenue_week_compare <- datatable(df_revenue_week_compare, rownames = FALSE, class = 'cell-border stripe',
                                     caption = 'Comparing Total Revenue Change (%)',
                                     options = list(dom = 't'))

dt_revenue_week_compare


```

$~$

Finally, we will explore the distribution of our customers in terms of the revenue generated. We first calculated the 25, 50 and 75 percentiles and use these to bucket the customers into low, medium, and high revenue. As we can see the low and high revenue customers seem to be equally distributed, with the majority of our customers falling into the mid-revenue group.

```{r revenue percentiles}

# Calculating Percentiles

df_percentiles_revenue <- dbGetQuery(con, "WITH user_revenues AS(
                                     SELECT customer_id, SUM(amount) AS revenue
                                     FROM payment
                                     GROUP BY customer_id)
                                     
                                     SELECT ROUND(PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY revenue ASC)::NUMERIC, 2) AS revenue_p25,
                                     ROUND(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY revenue ASC)::NUMERIC, 2) AS revenue_p50,
                                     ROUND(PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY revenue ASC)::NUMERIC, 2) AS revenue_p75
                                     FROM user_revenues")


# Use these percentiles for bucketing
df_user_revenue_bucket <- dbGetQuery(con, "WITH user_revenues AS(
                                     SELECT customer_id, SUM(amount) AS revenue
                                     FROM payment
                                     GROUP BY customer_id)
                                     
                                     SELECT CASE WHEN revenue < 86 THEN 'Low-Revenue'
                                     WHEN revenue >= 86 AND revenue < 117 THEN 'Mid-Revenue'
                                     ELSE 'High-revenue' END AS revenue_group,
                                     COUNT(DISTINCT customer_id) AS total_users
                                     FROM user_revenues
                                     GROUP BY revenue_group")

dt_user_revenue_bucket <- datatable(df_user_revenue_bucket, rownames = FALSE, class = 'cell-border stripe',
                                    caption = 'Customer Count by Revenue Group',
                                    options = list(dom = 't'))

dt_user_revenue_bucket

```

$~$

# Late returns
In this section we will explore which movies were often returned late. By identifying these movies we can then begin to further explore why they are returned late and consider increasing the rental duration for these movies. As we can see the movies most returned late were:

* Ridgemont Submarine	
* Butterfly Chocolat	
* Telegraph Voyage

```{r late return movies}
df_films_late <- dbGetQuery(con, "SELECT rm.title, COUNT(rm.title) AS total_times_late
           FROM (SELECT f.title, EXTRACT(DAY FROM r.return_date - r.rental_date) AS range, rental_duration
           FROM rental AS r
           INNER JOIN inventory AS i
           ON r.inventory_id = i.inventory_id
           INNER JOIN film as f
           ON i.film_id = f.film_id
           WHERE EXTRACT(DAY FROM r.return_date - r.rental_date) > rental_duration) AS rm
           GROUP BY rm.title
           ORDER BY total_times_late DESC
           LIMIT 20")

dt_films_late <- datatable(df_films_late, rownames = FALSE, class = 'cell-border stripe',
          caption = 'Movies Returned Late Count',
           options = list(dom = 'tp'))

dt_films_late

```

$~$

# Rentals by Country and Genre
In this final section we will explore the total rentals by country and genre. This will allow us to identify what countries we have a large customer base in and the favorite genre of these customers. This will allow us to make targeted promotions for these countries. 

This is similar to an excel pivot table. From this table we can identify China and India as being the countries with the largest customer bases (You can filter this table using the search bar). The most popular genre in China is Animation and the most popular genre in India is Action.

```{r rentals country genre}

# Rentals by country and genre
df_rentals_grouping_set <- dbGetQuery(con, "WITH temp_table AS(
                                      SELECT co.country, ca.name
                                      FROM rental AS r
                                      INNER JOIN inventory AS i
                                      ON r.inventory_id = i.inventory_id
                                      INNER JOIN film_category AS fc
                                      ON i.film_id = fc.film_id
                                      INNER JOIN category AS ca
                                      ON fc.category_id = ca.category_id
                                      INNER JOIN customer
                                      ON r.customer_id = customer.customer_id
                                      INNER JOIN address
                                      ON customer.address_id = address.address_id
                                      INNER JOIN city
                                      ON address.city_id = city.city_id
                                      INNER JOIN country AS co
                                      ON city.country_id = co.country_id)
                                      
                                      SELECT country, name, count(*)
                                      FROM temp_table
                                      GROUP BY GROUPING SETS((country,name), (country), ())
                                      ORDER BY country, name, count DESC")

dt_rentals_grouping_set <- datatable(df_rentals_grouping_set, rownames = FALSE, class = 'cell-border stripe',
          caption = 'Total Rentals by Country and Genre')

dt_rentals_grouping_set

```

$~$

# Part 2 Automating Data Comparisons

In this section we will extract data from the database and then carry out some checks automatically using programming and R, we will then output these checks to an Excel table. The goal of this section is to demonstrate the value of automating certain tasks that may previously have been done manually. For this function, the user will input the week they are interested in, i.e, for week 1, input 1. The function will then find this week, and the nearest previous week. The nearest previous week was chosen as there are issues within the database in terms of missing weeks. Once the weeks have been chosen, the function will extract the total revenue by genre for the two weeks and calculate a percentage change. Decreases in revenue will be highlighted red and exported to an excel table for the user to explore. Additionally, a second tab will be exported containing summary information about that week such as the total rentals, total revenue, and total missing values. 

Note: Due to the missing weeks, a list of valid weeks will be provided to the user, if the user inputs an invalid week, the function will return an error explaining this.

An example of this functions output is displayed below for week 5.

Please use the "Code" buttons to display the code for:

* Data preparation for the function
* Definition of the function

The business case for such a function is to allow for more streamlined data analysis. Users can quickly see which genres performed worse relative to the previous week and can then investigate the drivers of this change.

```{r excel checks data}
# data for function

# Extract revenue data
revenue_data <- dbGetQuery(con, "SELECT p.payment_date AS payment_date,
                              p.amount AS revenue,
                              p.payment_id AS payment_id,
                              c.name AS genre
                              FROM payment AS p
                           INNER JOIN rental AS r
                           ON p.rental_id = r.rental_id
                           INNER JOIN inventory AS i
                           ON r.inventory_id = i.inventory_id
                           INNER JOIN film AS f
                           ON i.film_id = f.film_id
                           INNER JOIN film_category AS fc
                           ON f.film_id = fc.film_id
                           INNER JOIN category AS c
                           ON fc.category_id = c.category_id")


# Convert the data field to a date class

revenue_data$payment_date <- as.Date(revenue_data$payment_date)


# Create new labels to identify which week are exploring
revenue_data_week <- revenue_data %>%
  mutate(week = cut.Date(payment_date, breaks = "1 week", labels = FALSE)) %>%
  arrange(payment_date)

# Calculate the total revenue by week and genre
revenue_data_select <- revenue_data_week %>%
  select(week, genre, revenue) %>%
  group_by(week, genre) %>%
  summarise(total_rev = sum(revenue))

# Define a list of valid weeks for the user
list_of_valid_weeks <- unique(revenue_data_select$week)

```


```{r excel checks}

# Defining the function

return_comparison <- function(user_week){
  
  # Check if the user has passed a valid week
  if(!user_week %in% list_of_valid_weeks){
    stop("Provided week is not in range. Please provide one of the following weeks:" , list_of_valid_weeks)
    
  }
  
  # Identify the nearest previous week
  week_prev <- revenue_data_select$week[which.max(revenue_data_select$week[revenue_data_select$week < user_week])]
  
  col_prev <- as.name(paste0("week_", week_prev))
  col_user <- as.name(paste0("week_", user_week))
  
  # Filter for the desired weeks
  temp_values <- revenue_data_select %>%
    filter(week %in% c(week_prev, user_week)) %>%
    mutate(new_week = paste0("week_", week)) %>%
    select(new_week, genre, total_rev)
  
  # Pivot the table wider for calculations
  temp_pivot <- pivot_wider(temp_values, names_from = new_week, values_from = total_rev)
  
  # Calculate the percentage change
  temp_sum <- temp_pivot %>%
    group_by(genre) %>%
    mutate(diff = ((!!col_user- !!col_prev) / !!col_prev) *100)
  return(temp_sum)
  
  temp_sum <- data.frame(temp_sum)
  
  # Write these changes to an excel document
  write.xlsx(temp_sum, "function_output.xlsx", sheetName = "Week Comparison", colNames = TRUE)
  
  # calculate some summaries
  total_revenue <- revenue_data_week %>%
    filter(week == 5) %>%
    summarise(total_rev = sum(revenue))
  
  total_missing <- revenue_data_week %>%
    filter(week == 5) %>% 
    summarise(total_miss = sum(is.na(revenue)))
  
  sheet_2_df <- data.frame(total_revenue,
                           total_missing)
  
  
  # Highlighting negative cells
  wb <- loadWorkbook("function_output.xlsx")
  redStyle <- createStyle(fontColour = "#000000", bgFill = "#FF0000")
  
  conditionalFormatting(wb, "Week Comparison", cols = 4,
                        rows = 1:nrow(temp_sum), rule = "<0", style = redStyle)
  
  addWorksheet(wb, "Week Stats")
  
  writeData(wb, sheet = "Week Stats", x = sheet_2_df)
  
  saveWorkbook(wb, "function_output.xlsx", overwrite = TRUE)
  
}

```

$~$

```{r excel check example}
excel_example$diff <- round(excel_example$diff,2)

dt_example <- datatable(excel_example, rownames = FALSE, class = 'cell-border stripe',
          caption = 'Example of Excel Function Output',
           options = list(dom = 'tp')) %>%
  formatStyle(
    columns = "diff",
    color = styleInterval(cuts = 0, values = c("red", "green")),
    fontWeight = "bold"
  )

dt_example

```

